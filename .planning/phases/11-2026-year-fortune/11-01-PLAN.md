---
phase: 11-2026-year-fortune
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/types/yearFortune.ts
  - backend/src/lib/yearFortuneCalculator.ts
  - backend/src/api/routes/yearFortune.ts
  - backend/src/api/index.ts
autonomous: true

must_haves:
  truths:
    - "丙午（2026年）の特徴データが定義されている"
    - "ユーザーの日干と丙午の関係性が計算される"
    - "2026年特有の運勢文章が生成される"
    - "年運計算APIエンドポイントが応答する"
    - "2027年以降にも拡張可能な汎用構造になっている"
  artifacts:
    - path: "backend/src/types/yearFortune.ts"
      provides: "年運タイプ定義"
      contains: "YearFortuneResult, YearData"
    - path: "backend/src/lib/yearFortuneCalculator.ts"
      provides: "年運計算ロジック"
      exports: ["calculateYearFortune", "getYearData"]
    - path: "backend/src/api/routes/yearFortune.ts"
      provides: "年運APIエンドポイント"
      exports: ["router"]
  key_links:
    - from: "backend/src/api/routes/yearFortune.ts"
      to: "backend/src/lib/yearFortuneCalculator.ts"
      via: "import { calculateYearFortune }"
    - from: "backend/src/lib/yearFortuneCalculator.ts"
      to: "backend/src/types/insen.ts"
      via: "SanmeigakuInsenChart参照"
    - from: "backend/src/api/index.ts"
      to: "/api/year-fortune"
      via: "app.use('/api/year-fortune', yearFortuneRouter)"
---

<objective>
Implement generic year fortune calculation system with 2026 (丙午) as first implementation

Purpose: Enable users to check their fortune for specific years, starting with 2026's special 丙午 characteristics. The system must be extensible for future years (2027, 2028, etc.).

Output: Working year fortune calculation with 丙午-specific content, API endpoint, and extensible year data structure
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-2026-year-fortune/11-CONTEXT.md
@.planning/phases/11-2026-year-fortune/11-RESEARCH.md

# Reference existing patterns
@backend/src/types/insen.ts
@backend/src/lib/compatibilityCalculator.ts
@backend/src/types/compatibility.ts
@backend/src/api/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create year fortune type definitions</name>
  <files>backend/src/types/yearFortune.ts</files>
  <action>
Create `backend/src/types/yearFortune.ts` with:

1. **YearData type** - Generic year information structure:
   - year: number (e.g., 2026)
   - kanshi: string (e.g., "丙午")
   - tenStem: string (e.g., "丙")
   - twelveBranch: string (e.g., "午")
   - element: "wood" | "fire" | "earth" | "metal" | "water"
   - yinYang: "yang" | "yin"
   - description: string (year characteristics explanation)
   - themes: string[] (key themes for the year)

2. **YearFortuneResult type** - Calculation result:
   - yearData: YearData
   - userElement: "wood" | "fire" | "earth" | "metal" | "water"
   - userStem: string (user's day stem)
   - compatibilityScore: number (0-100)
   - relationship: "productive" | "controlling" | "same" | "neutral"
   - fortune: {
       overall: string
       love: string
       work: string
       health: string
       advice: string
     }
   - highlights: string[] (key lucky points)

3. **Zod schema** for validation:
   - yearFortuneRequestSchema: { insen: SanmeigakuInsenChart, year?: number }
   - yearFortuneResponseSchema: YearFortuneResult

Import SanmeigakuInsenChart from existing types/insen.ts
  </action>
  <verify>grep -E "YearData|YearFortuneResult" backend/src/types/yearFortune.ts | wc -l > 5</verify>
  <done>Type file exists with YearData, YearFortuneResult, and Zod schemas</done>
</task>

<task type="auto">
  <name>Task 2: Implement year fortune calculator</name>
  <files>backend/src/lib/yearFortuneCalculator.ts</files>
  <action>
Create `backend/src/lib/yearFortuneCalculator.ts` with:

1. **YEAR_DATA_MAP** - Extensible year data registry:
   - 2026: { year: 2026, kanshi: "丙午", tenStem: "丙", twelveBranch: "午", element: "fire", yinYang: "yang", description: "丙午は火のエネルギーが最も強まる年。情熱、変革、エネルギッシュな一年になる。火の気が燃え上がるように、新しい始まりに適した年。", themes: ["情熱", "変革", "エネルギー", "新しい始まり"] }
   - Structure ready for 2027, 2028...

2. **getYearData(year: number): YearData** - Retrieve year data or throw

3. **calculateYearFortune(insen: SanmeigakuInsenChart, year: number = 2026): YearFortuneResult**:
   a. Get year data using getYearData()
   b. Extract user's day stem element from insen (reuse compatibilityCalculator's STEM_TO_ELEMENT pattern)
   c. Calculate compatibility score:
      - Use same ELEMENT_RELATIONS matrix from compatibilityCalculator
      - Base score from user element vs year element
      - Apply bonus/penalty for 干合 (kango) combinations
   d. Determine relationship: "productive" (相生), "controlling" (相剋), "same" (同五行), "neutral"
   e. Generate fortune content based on:
      - Year themes
      - User-year compatibility
      - Specific 丙午 characteristics (火のエネルギー強調)
   f. Return YearFortuneResult with all fields

Reuse patterns from compatibilityCalculator.ts:
   - STEM_TO_ELEMENT mapping
   - ELEMENT_RELATIONS matrix
   - KANGO_COMBINATIONS array
   - getDayStemElement helper

DO NOT duplicate existing constants - import from compatibilityCalculator
  </action>
  <verify>grep -E "calculateYearFortune|getYearData|YEAR_DATA_MAP" backend/src/lib/yearFortuneCalculator.ts | wc -l > 5</verify>
  <done>Calculator exists with 2026 data, extensible structure, and reuses compatibility patterns</done>
</task>

<task type="auto">
  <name>Task 3: Create year fortune API endpoint</name>
  <files>backend/src/api/routes/yearFortune.ts backend/src/api/index.ts</files>
  <action>
1. Create `backend/src/api/routes/yearFortune.ts`:
   - POST /calculate endpoint
   - Validate request with yearFortuneRequestSchema
   - Call calculateYearFortune() with insen and optional year (default 2026)
   - Return YearFortuneResult with 200 status
   - Handle errors with proper 400/500 responses
   - Follow same pattern as compatibility.ts route

2. Update `backend/src/api/index.ts`:
   - Import yearFortuneRouter from './routes/yearFortune'
   - Add: app.use('/api/year-fortune', yearFortuneRouter)
   - Maintain existing route registrations

Follow existing API route patterns:
   - Request validation with Zod
   - Consistent error handling
   - TypeScript types on request/response
  </action>
  <verify>grep -E "year-fortune|yearFortune" backend/src/api/index.ts && grep -E "POST.*calculate" backend/src/api/routes/yearFortune.ts</verify>
  <done>API endpoint /api/year-fortune/calculate accepts insen data and returns year fortune</done>
</task>

</tasks>

<verification>
After implementation, verify:

1. Type safety: tsc --noEmit passes without errors
2. API returns valid response: Test with POST /api/year-fortune/calculate
3. 2026 data includes 丙午 characteristics
4. Extensibility: Adding 2027 data only requires YEAR_DATA_MAP entry
5. Reuses existing compatibility patterns (no duplication)
</verification>

<success_criteria>
1. POST /api/year-fortune/calculate accepts {insen: SanmeigakuInsenChart, year?: number}
2. Response includes all YearFortuneResult fields with proper types
3. 2026 (丙午) returns fire-element specific content
4. Compatibility score calculation matches existing compatibilityCalculator logic
5. Code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-2026-year-fortune/11-01-SUMMARY.md`
</output>
