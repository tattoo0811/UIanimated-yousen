---
phase: 10-friend-compatibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/lib/compatibilityCalculator.ts
  - backend/src/types/compatibility.ts
autonomous: true

must_haves:
  truths:
    - "Backend calculates compatibility scores between multiple people's insen data"
    - "Compatibility calculation considers five elements relationships (Áõ∏Áîü/Áõ∏Ââã)"
    - "API endpoint accepts multiple birthdates and returns comparison results"
    - "Response includes overall score and aspect-specific scores (love/work/friendship)"
    - "Calculation is deterministic (same inputs produce same outputs)"
  artifacts:
    - path: "backend/src/lib/compatibilityCalculator.ts"
      provides: "Multi-person compatibility calculation logic"
      exports: ["calculateCompatibility", "compareMultiplePeople"]
      min_lines: 80
    - path: "backend/src/types/compatibility.ts"
      provides: "Type definitions for compatibility results"
      exports: ["CompatibilityResult", "CompatibilityScore", "PersonData"]
      min_lines: 30
    - path: "backend/src/api/routes/compatibility.ts"
      provides: "Express route for compatibility calculation"
      exports: ["POST /api/compatibility/calculate"]
      min_lines: 40
  key_links:
    - from: "backend/src/api/routes/compatibility.ts"
      to: "backend/src/lib/compatibilityCalculator.ts"
      via: "import { calculateCompatibility }"
      pattern: "calculateCompatibility"
    - from: "backend/src/lib/compatibilityCalculator.ts"
      to: "mobile/src/lib/logic/insen.ts"
      via: "Reference existing insen calculation patterns"
      pattern: "SanmeigakuInsenChart"
---

<objective>
Create backend compatibility calculation logic that enables multi-person comparison based on Èô∞ÈôΩ‰∫îË°å (In-Yo Gogyo) principles.

Purpose: Enable server-side compatibility scoring that can be used for video generation and API responses. Backend calculation ensures consistency across mobile app and video generation.

Output: Compatibility calculation library with API endpoint accepting multiple people's birth data and returning structured compatibility scores.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference existing mobile compatibility implementation
@mobile/src/lib/compatibility.ts
@mobile/src/lib/logic/insen.ts

# Reference existing backend patterns
@backend/src/api/controllers/renderController.ts
@backend/src/lib/contentTranslator.ts
</context>

<tasks>

<task type="auto">
  <name>Create compatibility type definitions</name>
  <files>backend/src/types/compatibility.ts</files>
  <action>
Create type definitions for compatibility calculation:

```typescript
export interface PersonData {
  name: string;
  birthDate: string; // ISO 8601 format
  gender: 'male' | 'female';
  insen: SanmeigakuInsenChart; // Import from existing types
}

export interface CompatibilityScore {
  overall: number; // 0-100
  love: number; // 0-100
  work: number; // 0-100
  friendship: number; // 0-100
}

export interface CompatibilityResult {
  scores: CompatibilityScore;
  level: 'perfect' | 'great' | 'good' | 'neutral' | 'challenging';
  message: string;
  advice: string;
  comparisons: Array<{
    person1: string;
    person2: string;
    score: number;
    strengths: string[];
    challenges: string[];
  }>;
}

export interface MultiPersonComparison {
  people: PersonData[];
  matrix: number[][]; // Compatibility matrix
  rankings: Array<{
    person: string;
    averageScore: number;
    bestMatch: string;
    bestMatchScore: number;
  }>;
}
```

Import SanmeigakuInsenChart from existing backend types or create it if not exists.
  </action>
  <verify>
File exists with all exported types. No TypeScript errors.
  </verify>
  <done>
Type definitions file created with all required interfaces and exports.
  </done>
</task>

<task type="auto">
  <name>Implement compatibility calculation library</name>
  <files>backend/src/lib/compatibilityCalculator.ts</files>
  <action>
Create compatibility calculation logic based on Èô∞ÈôΩ‰∫îË°å principles:

```typescript
import type { PersonData, CompatibilityResult, CompatibilityScore, MultiPersonComparison } from '../types/compatibility';
import type { SanmeigakuInsenChart } from '../types/insen';

// Five elements (‰∫îË°å) mapping from heavenly stems (Â§©Âπ≤)
const STEM_TO_ELEMENT: Record<string, 'wood' | 'fire' | 'earth' | 'metal' | 'water'> = {
  'Áî≤': 'wood', '‰πô': 'wood',
  '‰∏ô': 'fire', '‰∏Å': 'fire',
  'Êàä': 'earth', 'Â∑±': 'earth',
  'Â∫ö': 'metal', 'Ëæõ': 'metal',
  'Â£¨': 'water', 'Áô∏': 'water',
};

// Áõ∏Áîü (productive) and Áõ∏Ââã (controlling) relationships
const ELEMENT_RELATIONS: Record<string, Record<string, number>> = {
  wood: { wood: 70, fire: 90, earth: 40, metal: 30, water: 85 },
  fire: { wood: 85, fire: 70, earth: 90, metal: 40, water: 30 },
  earth: { wood: 40, fire: 85, earth: 70, metal: 90, water: 40 },
  metal: { wood: 30, fire: 40, earth: 85, metal: 70, water: 90 },
  water: { wood: 90, fire: 30, earth: 40, metal: 85, water: 70 },
};

// ÂçÅÂπ≤ (ten stems) compatibility combinations (Âπ≤Âêà)
const KANGO_COMBINATIONS = [
  ['Áî≤', 'Â∑±'], ['‰πô', 'Â∫ö'], ['‰∏ô', 'Ëæõ'], ['‰∏Å', 'Â£¨'], ['Êàä', 'Áô∏']
];

function getDayStemElement(insen: SanmeigakuInsenChart): 'wood' | 'fire' | 'earth' | 'metal' | 'water' {
  const dayStem = insen.meta.dayStem;
  return STEM_TO_ELEMENT[dayStem] || 'earth';
}

function calculateElementCompatibility(
  element1: 'wood' | 'fire' | 'earth' | 'metal' | 'water',
  element2: 'wood' | 'fire' | 'earth' | 'metal' | 'water'
): number {
  return ELEMENT_RELATIONS[element1][element2];
}

function checkKango(stem1: string, stem2: string): boolean {
  return KANGO_COMBINATIONS.some(pair =>
    (pair[0] === stem1 && pair[1] === stem2) ||
    (pair[0] === stem2 && pair[1] === stem1)
  );
}

export function calculateCompatibility(
  person1: PersonData,
  person2: PersonData
): CompatibilityResult {
  const stem1 = person1.insen.meta.dayStem;
  const stem2 = person2.insen.meta.dayStem;
  const element1 = getDayStemElement(person1.insen);
  const element2 = getDayStemElement(person2.insen);

  // Base score from element relationship
  let baseScore = calculateElementCompatibility(element1, element2);

  // Bonus for Âπ≤Âêà (kango) combinations
  const isKango = checkKango(stem1, stem2);
  if (isKango) baseScore += 20;

  // Calculate aspect scores with slight variations
  const loveScore = Math.min(100, baseScore + (isKango ? 10 : 0));
  const workScore = Math.min(100, baseScore + (element1 === element2 ? 5 : -5));
  const friendshipScore = Math.min(100, baseScore + (Math.abs(baseScore - 70) < 10 ? 5 : 0));

  const overallScore = Math.floor((loveScore * 0.35 + workScore * 0.3 + friendshipScore * 0.35));

  const level = getCompatibilityLevel(overallScore);
  const message = getCompatibilityMessage(level);
  const advice = generateAdvice(person1, person2, level);

  return {
    scores: {
      overall: overallScore,
      love: loveScore,
      work: workScore,
      friendship: friendshipScore,
    },
    level,
    message,
    advice,
    comparisons: [{
      person1: person1.name,
      person2: person2.name,
      score: overallScore,
      strengths: generateStrengths(element1, element2, isKango),
      challenges: generateChallenges(element1, element2),
    }],
  };
}

export function compareMultiplePeople(people: PersonData[]): MultiPersonComparison {
  const n = people.length;
  const matrix: number[][] = Array(n).fill(null).map(() => Array(n).fill(0));

  // Fill compatibility matrix
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const result = calculateCompatibility(people[i], people[j]);
      matrix[i][j] = result.scores.overall;
      matrix[j][i] = result.scores.overall; // Symmetric
    }
  }

  // Calculate rankings
  const rankings = people.map((person, i) => {
    const scores = matrix[i].filter((_, j) => j !== i);
    const averageScore = scores.reduce((a, b) => a + b, 0) / (n - 1);
    const bestMatchIndex = scores.indexOf(Math.max(...scores));
    const bestMatch = people[bestMatchIndex].name;
    const bestMatchScore = matrix[i][bestMatchIndex];

    return {
      person: person.name,
      averageScore: Math.round(averageScore),
      bestMatch,
      bestMatchScore,
    };
  }).sort((a, b) => b.averageScore - a.averageScore);

  return { people, matrix, rankings };
}

function getCompatibilityLevel(score: number): CompatibilityResult['level'] {
  if (score >= 90) return 'perfect';
  if (score >= 75) return 'great';
  if (score >= 60) return 'good';
  if (score >= 40) return 'neutral';
  return 'challenging';
}

function getCompatibilityMessage(level: CompatibilityResult['level']): string {
  const messages = {
    perfect: 'ÈÅãÂëΩ„ÅÆÁõ∏ÊâãÔºÅÂ•áË∑°ÁöÑ„Å™Áõ∏ÊÄß„Åß„Åô‚ú®',
    great: 'Á¥†Êô¥„Çâ„Åó„ÅÑÁõ∏ÊÄßÔºÅÈï∑„ÅèÁ∂ö„ÅèÈñ¢‰øÇ„ÅåÁØâ„Åë„Åù„ÅÜüíï',
    good: 'ËâØ„ÅÑÁõ∏ÊÄßÔºÅÂä™ÂäõÊ¨°Á¨¨„Åß„Åï„Çâ„Å´ËâØ„Åè„Å™„Çãüòä',
    neutral: 'ÊôÆÈÄö„ÅÆÁõ∏ÊÄß„ÄÇ„Åä‰∫í„ÅÑ„ÅÆÁêÜËß£„ÅåÈçµü§ù',
    challenging: 'Ë©¶Á∑¥„ÅÆÁõ∏ÊÄß„ÄÇ‰πó„ÇäË∂ä„Åà„Çå„Å∞Âº∑„ÅÑÁµÜ„Å´üí™',
  };
  return messages[level];
}

function generateAdvice(
  person1: PersonData,
  person2: PersonData,
  level: CompatibilityResult['level']
): string {
  const element1 = getDayStemElement(person1.insen);
  const element2 = getDayStemElement(person2.insen);

  if (level === 'perfect' || level === 'great') {
    return `${person1.name}„Å®${person2.name}„ÅØ„ÄÅ„Åä‰∫í„ÅÑ„ÅÆÂº∑„Åø„ÇíÊ¥ª„Åã„Åõ„ÇãÊúÄÈ´ò„ÅÆÁµÑ„ÅøÂêà„Çè„ÅõÔºÅËá™ÁÑ∂‰Ωì„Åß„ÅÑ„Çâ„Çå„ÇãÈñ¢‰øÇ„ÅåÁ∂ö„Åç„Åæ„Åô„ÄÇ`;
  } else if (level === 'good') {
    return `${person1.name}„Å®${person2.name}„ÅØ„ÄÅÊ≠©„ÅøÂØÑ„ÇäÊ¨°Á¨¨„Åß„Åï„Çâ„Å´Ê∑±„Åæ„Çå„ÇãÈñ¢‰øÇ„ÄÇÈÅï„ÅÑ„ÇíÊàêÈï∑„ÅÆ„ÉÅ„É£„É≥„Çπ„Å´„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ`;
  } else {
    return `${person1.name}„Å®${person2.name}„ÅØ„ÄÅÈÅï„ÅÑ„ÇíË™ç„ÇÅÂêà„ÅÜ„Åì„Å®„ÅåÂ§ßÂàá„ÄÇ„Ç≥„Éü„É•„Éã„Ç±„Éº„Ç∑„Éß„É≥„ÇíÂ§ßÂàá„Å´„Åô„Çå„Å∞Âº∑„ÅÑÁµÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ`;
  }
}

function generateStrengths(
  element1: string,
  element2: string,
  isKango: boolean
): string[] {
  const strengths: string[] = [];

  if (isKango) strengths.push('Âπ≤Âêà„ÅÆÈÅãÂëΩÁöÑ„Å™Áπã„Åå„Çä');
  if (element1 === element2) strengths.push('Âêå„Åò‰∫îË°å„ÅßÁêÜËß£„ÅóÂêà„Åà„Çã');
  if (ELEMENT_RELATIONS[element1][element2] >= 85) {
    strengths.push('Áõ∏ÁîüÈñ¢‰øÇ„ÅßÈ´ò„ÇÅÂêà„Åà„Çã');
  }

  return strengths.length > 0 ? strengths : ['Âà∫ÊøÄ„ÅóÂêà„Åà„ÇãÈñ¢‰øÇ'];
}

function generateChallenges(element1: string, element2: string): string[] {
  const challenges: string[] = [];

  if (ELEMENT_RELATIONS[element1][element2] < 50) {
    challenges.push('Áõ∏ÂâãÈñ¢‰øÇ„ÅßË°ùÁ™Å„Åó„ÇÑ„Åô„ÅÑ');
  }
  if (element1 !== element2 && ELEMENT_RELATIONS[element1][element2] < 85) {
    challenges.push('‰æ°ÂÄ§Ë¶≥„ÅÆÈÅï„ÅÑ„Çí‰πó„ÇäË∂ä„Åà„ÇãÂøÖË¶Å„ÅÇ„Çä');
  }

  return challenges.length > 0 ? challenges : ['Áâπ„Å´„Å™„Åó'];
}
```

Key implementation details:
1. Use existing SanmeigakuInsenChart type from mobile or create backend equivalent
2. Base calculation on five elements (‰∫îË°å) relationships from mobile/src/lib/compatibility.ts
3. Ensure deterministic calculations (no Math.random() - same inputs always produce same outputs)
4. Return structured results suitable for both API and video generation
  </action>
  <verify>
Run: npx tsc --noEmit (ensure no type errors)
Check: All functions are exported and typed correctly
  </verify>
  <done>
compatibilityCalculator.ts created with calculateCompatibility and compareMultiplePeople functions. All types properly defined.
  </done>
</task>

<task type="auto">
  <name>Create compatibility API endpoint</name>
  <files>backend/src/api/routes/compatibility.ts</files>
  <action>
Create Express route for compatibility calculation:

```typescript
import { Router } from 'express';
import { calculateCompatibility, compareMultiplePeople } from '../../lib/compatibilityCalculator';
import type { PersonData, CompatibilityResult, MultiPersonComparison } from '../../types/compatibility';
import { calculateBaZi } from 'yinyang-app-core'; // TODO: Import from correct location
import { calculateSanmeigakuInsen } from '../../lib/insen'; // TODO: Create or import insen calculation

const router = Router();

interface CalculateRequest {
  people: Array<{
    name: string;
    birthDate: string;
    gender: 'male' | 'female';
  }>;
}

// POST /api/compatibility/calculate
router.post('/calculate', async (req, res) => {
  try {
    const { people }: CalculateRequest = req.body;

    // Validate input
    if (!people || people.length < 2) {
      return res.status(400).json({
        error: 'At least 2 people required for compatibility calculation',
      });
    }

    if (people.length > 10) {
      return res.status(400).json({
        error: 'Maximum 10 people allowed',
      });
    }

    // Calculate insen for each person
    const peopleWithInsen: PersonData[] = await Promise.all(
      people.map(async (person) => {
        const birthDate = new Date(person.birthDate);
        // TODO: Use actual bazi/insen calculation
        // const bazi = calculateBaZi(birthDate);
        // const insen = calculateSanmeigakuInsen(bazi, birthDate);

        // Placeholder insen data
        const insen = {
          meta: {
            dayStem: 'Áî≤', // TODO: Calculate from birthDate
            calendar: 'solar' as const,
          },
          pillars: {
            year: { stem: 'Áî≤', branch: 'Â≠ê' },
            month: { stem: 'Áî≤', branch: 'Â≠ê' },
            day: { stem: 'Áî≤', branch: 'Â≠ê' },
          },
          hiddenStems: [],
          tsuhensei: [],
          junishiUn: [],
          fiveElements: {
            distribution: { wood: 3, fire: 2, earth: 2, metal: 1, water: 2 },
            dayStemStrength: 'strong' as const,
          },
          phaseRelations: [],
          tenchusatsu: {
            type: 'None',
            missingBranches: [],
          },
        };

        return {
          ...person,
          insen,
        };
      })
    );

    // For 2 people, return detailed compatibility
    if (peopleWithInsen.length === 2) {
      const result: CompatibilityResult = calculateCompatibility(
        peopleWithInsen[0],
        peopleWithInsen[1]
      );
      return res.json(result);
    }

    // For 3+ people, return multi-person comparison
    const result: MultiPersonComparison = compareMultiplePeople(peopleWithInsen);
    return res.json(result);

  } catch (error) {
    console.error('Compatibility calculation error:', error);
    res.status(500).json({
      error: 'Failed to calculate compatibility',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

export default router;
```

Then register the route in backend/src/api/index.ts:
```typescript
import compatibilityRouter from './routes/compatibility';
app.use('/api/compatibility', compatibilityRouter);
```

Note: This task includes TODO comments for actual insen calculation integration. The core compatibility logic is implemented, but bazi/insen calculation requires existing mobile logic to be ported or integrated.
  </action>
  <verify>
Check: Route file created and exported
Check: Route registered in main API index
Test: POST to /api/compatibility/calculate returns valid JSON structure
  </verify>
  <done>
Compatibility API endpoint created at /api/compatibility/calculate. Accepts 2-10 people, returns detailed results for 2 people or matrix comparison for 3+ people.
  </done>
</task>

</tasks>

<verification>
Run backend typecheck: npx tsc --noEmit in backend/
Verify all exports are properly typed
Test API endpoint with curl or similar tool (manual verification acceptable)
</verification>

<success_criteria>
1. Compatibility calculation library handles 2-10 people
2. Five elements (‰∫îË°å) relationships properly implemented (Áõ∏Áîü/Áõ∏Ââã)
3. API endpoint accepts birthdates and returns structured compatibility data
4. Deterministic calculations (no randomness)
5. TypeScript compilation succeeds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-friend-compatibility/10-01-SUMMARY.md`
</output>
