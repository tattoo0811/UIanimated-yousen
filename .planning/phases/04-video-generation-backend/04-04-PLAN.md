---
phase: 04-video-generation-backend
plan: 04
type: execute
wave: 4
depends_on: ["04-03"]
files_modified:
  - backend/src/api/index.ts
  - backend/src/api/routes/generate.ts
  - backend/src/api/routes/status.ts
  - backend/src/api/controllers/renderController.ts
  - backend/src/services/cloudrun.ts
  - backend/cloudbuild.yaml
autonomous: true

user_setup:
  - service: google-cloud
    why: "Cloud Run deployment and Cloud Storage bucket for video rendering"
    env_vars:
      - name: REMOTION_SERVICE_NAME
        source: "After deployment: Cloud Run service name"
      - name: REMOTION_SERVE_URL
        source: "After deployment: Cloud Storage serve URL"
      - name: GCS_BUCKET_NAME
        source: "After deployment: GCS bucket name from deployService()"
    dashboard_config:
      - task: "Deploy Cloud Run service with deployService()"
        location: "Run deployment script after API setup complete"
      - task: "Create GCS bucket if not exists"
        location: "Automatically created by getOrCreateBucket()"

must_haves:
  truths:
    - "Express API server with POST /api/video/generate endpoint exists"
    - "GET /api/video/status/:jobId endpoint returns render progress"
    - "renderController.ts implements renderMediaOnCloudrun() and getRenderProgress()"
    - "Cloud Run deployment script (deploy.ts) exists"
    - "API returns jobId immediately, supports polling for progress"
  artifacts:
    - path: "backend/src/api/index.ts"
      provides: "Express server setup"
      exports: ["app"]
    - path: "backend/src/api/routes/generate.ts"
      provides: "POST /api/video/generate endpoint"
      contains: "renderMediaOnCloudrun"
    - path: "backend/src/api/routes/status.ts"
      provides: "GET /api/video/status/:jobId endpoint"
      contains: "getRenderProgress"
    - path: "backend/src/services/cloudrun.ts"
      provides: "Cloud Run deployment functions"
      exports: ["deployService", "deploySite", "getOrCreateBucket"]
  key_links:
    - from: "backend/src/api/routes/generate.ts"
      to: "backend/src/api/controllers/renderController.ts"
      via: "import triggerRender"
      pattern: "import.*triggerRender"
    - from: "backend/src/api/controllers/renderController.ts"
      to: "@remotion/cloudrun/client"
      via: "renderMediaOnCloudrun"
      pattern: "renderMediaOnCloudrun.*from.*@remotion/cloudrun/client"
    - from: "backend/src/api/routes/status.ts"
      to: "@remotion/cloudrun/client"
      via: "getRenderProgress"
      pattern: "getRenderProgress.*from.*@remotion/cloudrun/client"
    - from: "backend/src/services/cloudrun.ts"
      to: "@remotion/cloudrun"
      via: "deployService, deploySite, getOrCreateBucket"
      pattern: "import.*deployService.*from.*@remotion/cloudrun"
---

<objective>
Create Express API endpoints with Cloud Run integration for video generation and progress polling.

**Purpose:** Implement REST API endpoints that trigger video rendering on Cloud Run and provide progress tracking via polling, enabling mobile app to request video generation and monitor completion status.

**Output:** Express server with POST /api/video/generate and GET /api/video/status/:jobId endpoints, renderController with @remotion/cloudrun/client integration, Cloud Run deployment script.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-video-generation-backend/04-CONTEXT.md
@.planning/phases/04-video-generation-backend/04-RESEARCH.md

# Prior work
- 04-01: Backend setup, package.json with express, cors, @remotion/cloudrun dependencies
- 04-02: VideoTemplate base component
- 04-03: HookComposition with 7-second hook structure and typing effects

# Research references
- API endpoints: POST /api/video/generate (returns jobId), GET /api/video/status/:jobId (returns progress)
- Progress tracking: polling at 3-5 second intervals, 30-second timeout
- Cloud Run functions: deployService(), deploySite(), getOrCreateBucket()
- renderMediaOnCloudrun() for triggering renders, getRenderProgress() for status checks
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create render controller with Cloud Run client</name>
  <files>backend/src/api/controllers/renderController.ts, backend/src/services/cloudrun.ts</files>
  <action>
Create **backend/src/api/controllers/renderController.ts**:

```typescript
import {renderMediaOnCloudrun, getRenderProgress} from '@remotion/cloudrun/client';
import {hookCompositionSchema} from '../../compositions/HookComposition';

interface GenerateVideoParams {
  nickname: string;
  fortuneData: {
    result: string;
    rating: number;
  };
  theme: 'KiraPop' | 'MonoEdge' | 'ZenWa';
  tone: 'TikTok' | 'YouTube' | 'Instagram';
}

interface GenerateVideoResult {
  jobId: string;
  bucketName: string;
  status: 'pending';
}

interface RenderProgress {
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress?: number;
  videoUrl?: string;
  renderTime?: number;
  errors?: string[];
}

export const triggerRender = async (
  params: GenerateVideoParams
): Promise<GenerateVideoResult> => {
  // Validate input props
  const validatedProps = hookCompositionSchema.parse(params);

  const {
    bucketName,
    renderId,
  } = await renderMediaOnCloudrun({
    region: process.env.GCP_REGION || 'us-central1',
    serviceName: process.env.REMOTION_SERVICE_NAME || '',
    serveUrl: process.env.REMOTION_SERVE_URL || '',
    composition: 'HookComposition',
    inputProps: validatedProps,
    codec: 'h264',
    privacy: 'public',
    inputProps: validatedProps,
  });

  return {
    jobId: renderId,
    bucketName,
    status: 'pending',
  };
};

export const checkRenderProgress = async (
  jobId: string
): Promise<RenderProgress> => {
  const progress = await getRenderProgress({
    renderId: jobId,
    bucketName: process.env.GCS_BUCKET_NAME || '',
    region: process.env.GCP_REGION || 'us-central1',
    serviceName: process.env.REMOTION_SERVICE_NAME || '',
  });

  if (progress.done) {
    return {
      status: 'completed',
      videoUrl: progress.outputFile,
      renderTime: progress.timeToFinish,
    };
  }

  if (progress.fatalErrorEncountered) {
    return {
      status: 'failed',
      errors: progress.errors,
    };
  }

  return {
    status: 'processing',
    progress: Math.round(progress.overallProgress * 100),
  };
};
```

Create **backend/src/services/cloudrun.ts**:

```typescript
import {deployService, deploySite, getOrCreateBucket} from '@remotion/cloudrun';
import {bundle} from '@remotion/bundler';
import path from 'path';

interface DeploymentConfig {
  region: string;
  projectName: string;
  memorySizeInMb?: number;
  cpuCount?: number;
  timeoutInSeconds?: number;
}

interface DeploymentResult {
  serviceName: string;
  serveUrl: string;
  bucketName: string;
}

export const deployCloudRunService = async (
  config: DeploymentConfig
): Promise<DeploymentResult> => {
  const {
    region = 'us-central1',
    projectName,
    memorySizeInMb = 2048,  // 2GiB recommended minimum
    cpuCount = 2,            // 2 vCPU
    timeoutInSeconds = 300,  // 5 minutes
  } = config;

  // Step 1: Create or get existing GCS bucket
  const {bucketName} = await getOrCreateBucket({
    region,
  });

  // Step 2: Bundle Remotion site
  const bundlePath = await bundle({
    entryPoint: path.resolve('./src/index.ts'),
    webpackConfiguration: (config) => ({
      ...config,
      externals: [...(config.externals || []), 'sharp'],
    }),
  });

  // Step 3: Deploy Cloud Run service
  const {serviceName, uri} = await deployService({
    region,
    memorySizeInMb,
    cpuCount,
    timeoutInSeconds,
  });

  // Step 4: Deploy Remotion site bundle
  const {serveUrl} = await deploySite({
    entryPoint: path.resolve('./src/index.ts'),
    bucketName,
    siteName: `${projectName}-site`,
  });

  console.log(`Cloud Run service deployed: ${serviceName}`);
  console.log(`Service URI: ${uri}`);
  console.log(`Site deployed: ${serveUrl}`);
  console.log(`Bucket: ${bucketName}`);

  return {
    serviceName,
    serveUrl,
    bucketName,
  };
};
```

Why:
- renderController.ts implements triggerRender() and checkRenderProgress() using @remotion/cloudrun/client
- triggerRender() validates input with Zod schema, calls renderMediaOnCloudrun(), returns jobId immediately
- checkRenderProgress() calls getRenderProgress(), maps to status (pending/processing/completed/failed)
- cloudrun.ts provides deployment wrapper: deployService(), deploySite(), getOrCreateBucket()
- Resource configuration: 2GiB memory, 2 vCPU, 300s timeout (from 04-RESEARCH.md)

Reference:
- API endpoint patterns from 04-RESEARCH.md: POST /api/video/generate, GET /api/video/status/:jobId
- Cloud Run deployment: deployService(), deploySite(), getOrCreateBucket()
- Progress tracking: getRenderProgress() with overallProgress, done, fatalErrorEncountered
- Resource requirements: 2 vCPU / 2GiB / 300s timeout (04-RESEARCH.md)
  </action>
  <verify>
```bash
cd backend && grep -n "export.*triggerRender" src/api/controllers/renderController.ts
cd backend && grep -n "renderMediaOnCloudrun" src/api/controllers/renderController.ts
cd backend && grep -n "getRenderProgress" src/api/controllers/renderController.ts
cd backend && grep -n "deployCloudRunService" src/services/cloudrun.ts
cd backend && grep -n "deployService.*from.*@remotion/cloudrun" src/services/cloudrun.ts
```
  </verify>
  <done>
backend/src/api/controllers/renderController.ts exports triggerRender() and checkRenderProgress()
triggerRender() uses renderMediaOnCloudrun() from @remotion/cloudrun/client
checkRenderProgress() uses getRenderProgress() from @remotion/cloudrun/client
backend/src/services/cloudrun.ts exports deployCloudRunService() with deployService(), deploySite(), getOrCreateBucket()
Resource configuration: 2GiB memory, 2 vCPU, 300s timeout
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Express API routes and server setup</name>
  <files>backend/src/api/index.ts, backend/src/api/routes/generate.ts, backend/src/api/routes/status.ts, backend/cloudbuild.yaml</files>
  <action>
Create **backend/src/api/routes/generate.ts**:

```typescript
import {Router} from 'express';
import {triggerRender} from '../controllers/renderController';

const router = Router();

router.post('/generate', async (req, res) => {
  try {
    const {nickname, fortuneData, theme, tone} = req.body;

    const result = await triggerRender({
      nickname,
      fortuneData,
      theme,
      tone,
    });

    res.json({
      jobId: result.jobId,
      status: result.status,
      bucketName: result.bucketName,
      estimatedTimeSeconds: 30,
    });
  } catch (error) {
    console.error('Render trigger failed:', error);
    res.status(500).json({
      error: 'Failed to start render',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

export default router;
```

Create **backend/src/api/routes/status.ts**:

```typescript
import {Router} from 'express';
import {checkRenderProgress} from '../controllers/renderController';

const router = Router();

router.get('/status/:jobId', async (req, res) => {
  try {
    const {jobId} = req.params;

    const progress = await checkRenderProgress(jobId);

    if (progress.status === 'completed') {
      return res.json({
        status: 'completed',
        videoUrl: progress.videoUrl,
        renderTime: progress.renderTime,
      });
    }

    if (progress.status === 'failed') {
      return res.status(500).json({
        status: 'failed',
        errors: progress.errors,
      });
    }

    res.json({
      status: 'processing',
      progress: progress.progress,
    });
  } catch (error) {
    console.error('Progress check failed:', error);
    res.status(500).json({
      error: 'Failed to check progress',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

export default router;
```

Create **backend/src/api/index.ts**:

```typescript
import express from 'express';
import cors from 'cors';
import generateRoutes from './routes/generate';
import statusRoutes from './routes/status';

const app = express();

// Middleware
app.use(cors());
app.use(express.json());

// Health check
app.get('/health', (req, res) => {
  res.json({status: 'ok', service: 'video-render-api'});
});

// API routes
app.use('/api/video', generateRoutes);
app.use('/api/video', statusRoutes);

// Error handler
app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('Unhandled error:', err);
  res.status(500).json({
    error: 'Internal server error',
    message: err.message,
  });
});

const PORT = process.env.PORT || 8080;

app.listen(PORT, () => {
  console.log(`Render API listening on port ${PORT}`);
});

export default app;
```

Create **backend/cloudbuild.yaml** for CI/CD:

```yaml
steps:
  # Install dependencies
  - name: 'node:18'
    entrypoint: 'npm'
    args: ['ci']

  # Build Remotion bundle
  - name: 'node:18'
    entrypoint: 'npm'
    args: ['run', 'build']

  # Deploy to Cloud Run
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/fortune-video-backend', '.']

  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/fortune-video-backend']

  - name: 'gcr.io/cloud-builders/gcloud'
    args:
      - 'run'
      - 'deploy'
      - 'fortune-video-backend'
      - '--image'
      - 'gcr.io/$PROJECT_ID/fortune-video-backend'
      - '--platform'
      - 'managed'
      - '--region'
      - 'us-central1'
      - '--allow-unauthenticated'

# Cloud Run service configuration
timeout: '1200s'
```

Why:
- POST /api/video/generate accepts {nickname, fortuneData, theme, tone}, returns {jobId, status, bucketName}
- GET /api/video/status/:jobId returns {status, progress, videoUrl?, errors?}
- Express server with CORS, JSON body parsing, health check endpoint
- Error handling with try/catch and console.error logging
- cloudbuild.yaml for Cloud Build CI/CD (docker build, push, deploy)

Reference:
- API endpoint specification from 04-RESEARCH.md and 04-CONTEXT.md
- Progress management: polling 3-5 seconds, 30-second timeout (04-CONTEXT.md)
- Cloud Build integration for deployment automation

Note:
- API endpoints match specification for mobile app integration
- Estimated render time (30s) returned to client for timeout handling
- CORS enabled for cross-origin requests from mobile app
- Health check endpoint for Cloud Run liveness probe
  </action>
  <verify>
```bash
cd backend && grep -n "POST.*generate" src/api/routes/generate.ts
cd backend && grep -n "GET.*status" src/api/routes/status.ts
cd backend && grep -n "app.use.*api/video" src/api/index.ts
cd backend && grep -n "cors()" src/api/index.ts
cd backend && grep -n "gcloud.*run.*deploy" cloudbuild.yaml
```
  </verify>
  <done>
backend/src/api/routes/generate.ts implements POST /api/video/generate endpoint
backend/src/api/routes/status.ts implements GET /api/video/status/:jobId endpoint
backend/src/api/index.ts creates Express server with CORS, JSON middleware, health check
cloudbuild.yaml provides Cloud Build steps for CI/CD (npm ci, build, docker build/push, gcloud run deploy)
API routes mounted at /api/video prefix
Error handling with try/catch in all route handlers
  </done>
</task>

</tasks>

<verification>
After completing all tasks, verify:

1. **TypeScript compilation:**
```bash
cd backend && npx tsc --noEmit
```

2. **API routes are valid:**
```bash
cd backend && grep -r "router\." src/api/routes/
```

3. **Express server setup is complete:**
```bash
cd backend && grep -E "app\.use|app\.get|app\.listen" src/api/index.ts
```

4. **Cloud Build configuration is valid YAML:**
```bash
cd backend && cat cloudbuild.yaml | grep -E "steps:|name:|args:"
```
</verification>

<success_criteria>
Phase 04-04 is complete when:
- backend/src/api/controllers/renderController.ts exports triggerRender() and checkRenderProgress()
- triggerRender() uses renderMediaOnCloudrun() from @remotion/cloudrun/client
- checkRenderProgress() uses getRenderProgress() from @remotion/cloudrun/client
- backend/src/api/routes/generate.ts implements POST /api/video/generate endpoint
- backend/src/api/routes/status.ts implements GET /api/video/status/:jobId endpoint
- backend/src/api/index.ts creates Express server with CORS, health check, route mounting
- backend/src/services/cloudrun.ts exports deployCloudRunService() with Cloud Run deployment functions
- backend/cloudbuild.yaml provides Cloud Build CI/CD configuration
- All files pass TypeScript compilation
</success_criteria>

<output>
After completion, create `.planning/phases/04-video-generation-backend/04-04-SUMMARY.md`
</output>
