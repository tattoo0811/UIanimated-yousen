---
phase: 03-design-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mobile/src/themes/types.ts
  - mobile/src/themes/index.ts
  - mobile/src/contexts/ThemeContext.tsx
  - mobile/src/hooks/useTheme.ts
  - mobile/app/_layout.tsx
autonomous: true

must_haves:
  truths:
    - "Theme type definitions exist with ThemeId, ColorScheme, FontScheme, AnimationConfig"
    - "ThemeProvider provides theme, themeId, setTheme, isLoading to consumers"
    - "useTheme hook returns current theme context"
    - "Theme loads from AsyncStorage on app start with loading state"
    - "ThemeProvider wraps the app root in _layout.tsx"
  artifacts:
    - path: "mobile/src/themes/types.ts"
      provides: "Theme type definitions"
      exports: ["ThemeId", "Theme", "ColorScheme", "FontScheme", "AnimationConfig"]
    - path: "mobile/src/contexts/ThemeContext.tsx"
      provides: "Theme state management via Context API"
      exports: ["ThemeProvider"]
    - path: "mobile/src/hooks/useTheme.ts"
      provides: "Theme consumption hook"
      exports: ["useTheme"]
    - path: "mobile/app/_layout.tsx"
      provides: "App root wrapper with ThemeProvider"
  key_links:
    - from: "mobile/app/_layout.tsx"
      to: "mobile/src/contexts/ThemeContext.tsx"
      via: "import { ThemeProvider }"
      pattern: "ThemeProvider"
    - from: "mobile/src/contexts/ThemeContext.tsx"
      to: "@react-native-async-storage/async-storage"
      via: "AsyncStorage.getItem('@app_theme')"
      pattern: "AsyncStorage"
    - from: "mobile/src/hooks/useTheme.ts"
      to: "mobile/src/contexts/ThemeContext.tsx"
      via: "useContext(ThemeContext)"
      pattern: "ThemeContext"
---

<objective>
Design System Foundation â€” React Context-based theme system with type-safe theme definitions, AsyncStorage persistence, and app-wide theme provider
Purpose: Enable app-wide theming with hot-swappable design configurations
Output: Type-safe theme foundation ready for theme implementation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

@.planning/phases/03-design-system/03-CONTEXT.md
@.planning/phases/03-design-system/03-RESEARCH.md
@.planning/ROADMAP.md
@.planning/PROJECT.md

@mobile/src/hooks/useHapticFeedback.ts
@mobile/lib/animations.ts
@mobile/src/components/SwipeableStack.tsx
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/02-card-ui-core/02-03-SUMMARY.md
@.planning/phases/02-card-ui-core/02-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create theme type definitions</name>
  <files>mobile/src/themes/types.ts</files>
  <action>
Create mobile/src/themes/types.ts with:

1. **ThemeId type**: Union type 'kiraPop' | 'monoEdge' | 'zenWa'

2. **ThemeMode type**: 'light' | 'dark'

3. **ColorScheme interface**: primary, secondary, accent, background, surface, text, textSecondary (all string)

4. **FontScheme interface**: regular (string), bold (string), display? (optional string)

5. **AnimationConfig interface**:
   - spring: { damping: number, stiffness: number, mass: number }
   - timing: { duration: number }
   - swipe: { maxRotation: number, scaleAmount: number, fadeSpeed: number }

6. **Theme interface**:
   - id: ThemeId
   - name: { en: string, ja: string }
   - description: { en: string, ja: string }
   - colors: { light: ColorScheme, dark: ColorScheme }
   - fonts: FontScheme
   - animations: AnimationConfig

All types must export properly for use in other modules. Follow TypeScript strict mode - no any types.
  </action>
  <verify>
grep -q "export.*ThemeId" mobile/src/themes/types.ts && grep -q "export.*interface Theme" mobile/src/themes/types.ts && npx tsc --noEmit --skipLibCheck
  </verify>
  <done>
types.ts exports ThemeId, ThemeMode, ColorScheme, FontScheme, AnimationConfig, Theme interfaces with all required properties
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ThemeContext with AsyncStorage persistence</name>
  <files>mobile/src/contexts/ThemeContext.tsx</files>
  <action>
Create mobile/src/contexts/ThemeContext.tsx with:

1. **Imports**: React (useState, useEffect, useMemo, createContext, useContext), AsyncStorage from @react-native-async-storage/async-storage, Theme types

2. **ThemeContextType interface**:
   - theme: Theme
   - themeId: ThemeId
   - setTheme: (themeId: ThemeId) => Promise<void>
   - isLoading: boolean

3. **Context creation**: createContext<ThemeContextType | undefined>(undefined)

4. **ThemeProvider component**:
   - State: themeId (default 'kiraPop'), isLoading (true)
   - useEffect on mount: load from AsyncStorage key '@app_theme'
   - loadTheme async function: try/catch with AsyncStorage.getItem, setThemeIdState if valid, setIsLoading(false) in finally
   - setTheme async function: AsyncStorage.setItem then setThemeIdState
   - Memoized theme value using useMemo to prevent re-renders
   - Return Context.Provider with value={{ theme, themeId, setTheme, isLoading }}

5. **useTheme hook**: Returns context value, throws error if used outside provider

Use useMemo for theme object and context value to prevent unnecessary re-renders (pitfall #3).
Handle loading state to prevent theme flicker (pitfall #1).

Note: Task 3 will create the themes object that this imports. For now, use a placeholder import path.
  </action>
  <verify>
grep -q "ThemeProvider" mobile/src/contexts/ThemeContext.tsx && grep -q "useTheme" mobile/src/contexts/ThemeContext.tsx && grep -q "AsyncStorage" mobile/src/contexts/ThemeContext.tsx && npx tsc --noEmit --skipLibCheck
  </verify>
  <done>
ThemeContext.tsx exports ThemeProvider and useTheme hook with AsyncStorage persistence and loading state management
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useTheme hook file</name>
  <files>mobile/src/hooks/useTheme.ts</files>
  <action>
Create mobile/src/hooks/useTheme.ts as a simple re-export:

1. Import useTheme from ThemeContext
2. Export useTheme as named export

This provides a clean import path for components: `import { useTheme } from '@/src/hooks/useTheme'`
  </action>
  <verify>
grep -q "export.*useTheme" mobile/src/hooks/useTheme.ts && npx tsc --noEmit --skipLibCheck
  </verify>
  <done>
useTheme.ts exports useTheme hook from ThemeContext
  </done>
</task>

<task type="auto">
  <name>Task 4: Create themes index with placeholder exports</name>
  <files>mobile/src/themes/index.ts</files>
  <action>
Create mobile/src/themes/index.ts with:

1. Export types from types.ts: ThemeId, Theme, ThemeMode, ColorScheme, FontScheme, AnimationConfig

2. Create placeholder themes object (will be populated in plan 03-02):
   ```typescript
   import { Theme } from './types';

   export const themes: Record<string, Theme> = {
     // Placeholder - will be implemented in 03-02
   } as Record<string, Theme>;
   ```

3. Add TODO comment indicating themes will be implemented in 03-02

This file will be completed in plan 03-02 with the three theme implementations.
  </action>
  <verify>
grep -q "export.*themes" mobile/src/themes/index.ts && npx tsc --noEmit --skipLibCheck
  </verify>
  <done>
themes/index.ts exports type definitions and placeholder themes object
  </done>
</task>

<task type="auto">
  <name>Task 5: Integrate ThemeProvider into app root</name>
  <files>mobile/app/_layout.tsx</files>
  <action>
Update mobile/app/_layout.tsx:

1. Import ThemeProvider from '@/src/contexts/ThemeContext'
2. Import useTheme hook (will need to access fontsLoaded state)
3. Wrap existing root layout with ThemeProvider
4. Combine theme loading with existing font loading (useFonts) if present
5. Show existing loading screen while both fonts AND theme load
6. Only render children once both are ready

The loading state prevents theme flicker (pitfall #1) and font loading issues (pitfall #2).

Note: Font loading for theme-specific fonts will be added in plan 03-02.
  </action>
  <verify>
grep -q "ThemeProvider" mobile/app/_layout.tsx && npx tsc --noEmit --skipLibCheck
  </verify>
  <done>
_layout.tsx wraps app with ThemeProvider and shows loading state until theme loads
  </done>
</task>

</tasks>

<verification>
1. Type checking passes: `npx tsc --noEmit --skipLibCheck`
2. All files compile without errors
3. ThemeContext provides expected interface
4. useTheme hook is consumable by components
5. App root wrapped with ThemeProvider
</verification>

<success_criteria>
1. Theme types defined with full TypeScript type safety
2. ThemeContext with AsyncStorage persistence implemented
3. useTheme hook available for component consumption
4. App root wrapped with ThemeProvider
5. Loading state prevents theme flicker on app start
</success_criteria>

<output>
After completion, create `.planning/phases/03-design-system/03-01-SUMMARY.md`
</output>
